<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信期末提纲]]></title>
    <url>%2F2019%2F11%2F06%2F%E5%BE%AE%E4%BF%A1%E6%9C%9F%E6%9C%AB%E6%8F%90%E7%BA%B2%2F</url>
    <content type="text"><![CDATA[公众号 小程序 涉及技术： 前后端通信、安全加密、web协议（HTTPS/HTTP） 数据库、web开发框架、云服务器、备案 JSON 一种用于传输和存储数据的格式 简单、轻量、解析速度比较快 小程序：小程序项目目录结构 js文件控制页面逻辑 wxml以及wxss文件用于页面布局以及样式 |comps //自定义第三方组件|pages //页面所在的目录，每个页面都是其中一个目录| |index| | |index.js| | |index.json| | |index.wxml| | |index.wxss| || |info| |logs||utils //工具函数|app.js //小程序启动时，app.js中的APP实例会运行及初始化操作|app.json //小程序全局配置文件|___app.wxss //全局样式表 设置 tabBar12345678910'tabBar' :&#123; 'list' :[ &#123; 'pagePath':'', 'text':'', 'iconPath':'' &#125;, &#123;...&#125; ]&#125; 小程序没有DOM 和 BOM操作，框架核心是一个响应的数据绑定系统，在逻辑层修改数据路由 123switchTab(&#123;//跳转页面，需要在 app.json中tabBar定义页面 url:'/pages/index/index'&#125;) 123wx.reLaunch(&#123;//关闭所有页面，并打开应用的某个页面 url:'/pages/index/index'&#125;) 123wx.redirectTo(&#123;//关闭当前页面，跳转到应用的某个页面，但不允许跳到tabBar页面 url:'/pages/index/index'&#125;) 123wx.navigateTo(&#123;//...............并使用 wx.navigateBack() 可以返回原页面 url:'/pages/index/index'&#125;) 一些标签和属性 wx.getSystemInfo 获取系统信息 wx.getBatteryInfo 获取电量信息 wx.getNetworkType 网络状态信息 wx.onNetworkStatusChange 监听网络状态 startCompass 启用罗盘 在回调函数中调用 onCompassChange 监听变化 wx.onDeviceMotionChange 设备方向 titbit web框架123456789const titbit = require('titbit');var app = new titbit(&#123; debug : true&#125;);var &#123;router&#125; = app;router.get('/', async c =&gt;&#123; c.res.body = 'ok';&#125;);app.run(8080); 小程序页面生命周期（基本流程以及相关回调函数） 进入/切换一个新页面时，调用的生命周期函数 onLoad &gt; onReady &gt; onShow onLoad 监听页面加载 onShow 监听页面显示 onReady …初次渲染完成 onHide …隐藏 onUnLoad …卸载 onPullDownRefresh 监听用户下拉动作 onReachBottom 上拉触底 onShareAppMessage 点击右上角转发 onPageScroll 页面滚动触发事件 onTabItemTap 当前是tab页时，点击tab时触发 注册小程序以及如何对接开发者服务器域名的一些注意点和限制规则 限制必须要使用域名，并且不能使用端口号 一台服务器要运行多个服务，但对外仅仅提供80/443的端口访问，需要使用反向代理解决 小程序对接开发者域名需要通过签名证书开启HTTPS服务 编辑Nginx配置文件支持SSL 服务器开启HTTPS，域名要备案 小程序如何发起网络请求 发起请求前需要先在后台设置安全域名 通过API中的 wx.request 可以发起网络请求 常用的请求类型：GET、POST、PUT、DELETE、OPTIONS发起GET请求 12345678910wx.request(&#123; url:'https://a.example.com/test', data:&#123;name:'zhangsan'&#125;, dataType:'text', success:(res)=&gt;&#123; this.setData(&#123; getReturn:res.data &#125;) &#125;&#125;) 发起POST请求 1234567891011121314wx.request(&#123; url:'https://a.example.com/test', method:'POST', data:'123', dataType:'text', header:&#123; 'content-type':'application/x-www-form-urlencoded' &#125;, success:(res)=&gt;&#123; this.setData(&#123; postReturn:res.data &#125;) &#125;&#125;) 了解小程序的能力 ?（概括的了解其能力，能解决基础的问题） 本质上还是前端的内容，提交的小程序会被解析成前端数据 微信客户端内置浏览器，可以显示页面 小程序服务端API： 调用小程序服务端API需要AppID和AppSecret 获取 access_token URL参数携带 access_token调用API 公众号：客户端-微信服务器-开发者服务器之间的通信 通信过程的建立需要配置并验证，验证过程微信服务器会发送 GET请求，消息转发是 POST请求，两过程互斥； 开启服务器配置页面需要填写服务器地址和令牌； url（服务器地址）是开发者服务器的url，微信服务器会把用户发给公众号的消息转发至此； token（令牌）用于验证过程，开发者自己填写，微信服务器使用token生成验证签名，开发者通过签名，验证请求来自微信服务器； //密匙 //加密模式调用公众号API 消息通信： 要进行消息通信，需要开启开发者配置： URL：开发者服务器的URL，微信服务器会把用户发给公众号的消息消息转发到此 Token：用于验证过程。开发者自己填写，微信服务器使用 Token生成验证签名，开发者通过签名，验证请求来自微信服务器 //密钥 //加密模式 开启服务器配置的验证流程： 开发者设置URL，并在开发者服务器启动Web服务 填写Token和开发者服务器的Token一致 点击确认，腾讯服务器向开发者服务器URL发起请求 开发者服务器接收请求并验证数据是否合法 合法则返回指定值 验证过程请求数据的处理： 微信服务器向开发者服务器URL请求并携带以下参数：signature、timestamp、nonce、echostr 开发者服务器按照以下方式验证signature是否合法： 把token、timestamp、nonce字典排序 排序后的数据拼接成一个字符串 对拼接后的字符串进行shal加密 加密后的数据和signature对比是否相同 相同则返回echostr，标识次请求来自于微信服务器。 验证过程使用的是GET请求；而验证成功后，则会使用POST请求转发用户消息。 转发用户消息以及开发者恢复用户消息的格式：XMLXML是可扩展标记语言，被设计用来格式化数据 标签区分大小写 所有元素必须有闭合标签 必须有&lt;person&gt;根元素 属性必须加引号 如果开发者服务器不需要回复消息： 返回空字符串 返回success 公众号接口的调用： 和小程序调用过程一致，都要先获取access_token access_token接口每天可调用2000次 重新调用会导致上次获取的失效 区分公众号和小程序的AppID和AppSecret： 两个不是相同的，也并无关联 测试号： 测试号的一些特点和限制： 可以调用大部分高级接口用于开发测试 无法设置头像和名称 关注用户有上限，目前为100个 Nginx以及反向代理了解Nginx的反向代理模式和应用场景 Linux文件/目录： cd：切换工作目录 cp：复制文件/目录 mv：移动文件/目录，可用于重命名 rm：删除文件/目录，可删除非空目录 ls：显示文件详细信息以及目录内容 进程： ps：查看进程 kill：向进程发送信号，默认是SIGTERM表示中断进程]]></content>
  </entry>
  <entry>
    <title><![CDATA[React笔记（五）-redux]]></title>
    <url>%2F2019%2F11%2F06%2FReact%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-redux%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（六）-数据存储]]></title>
    <url>%2F2019%2F10%2F29%2FnodeJs%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[web静态文件服务]]></content>
  </entry>
  <entry>
    <title><![CDATA[React笔记（四）-router]]></title>
    <url>%2F2019%2F10%2F16%2FReact%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-router%2F</url>
    <content type="text"><![CDATA[路由配置安装React Router包含三个库，react-router、react-router-dom、react-router-native npm install –save react-router-dom 引入React Router 通过 Router 和 Route两个组件完成路由功能。 12345678910111213import &#123;BrowserRouter as Router,Route,Link&#125; from 'react-router-dom';exports default calss Hello extends Component&#123; render()&#123; return ( &lt;Router&gt; &lt;div&gt; &lt;Route exact path='/' component=&#123;Home&#125;/&gt; &lt;Route path='/about' component=&#123;About&#125;/&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125; BrowserRouter 和 HashRouter特点 都是路由的基本组件，需将其放在最外层，选其一使用 内部只能含有一个子节点 BrowserRouter 的URL是指向真实URL的资源路径，页面和浏览器的history保持一致 HashRouter 使用URL中的hash（#）部分去创建路由 http://example.com/#/some/path BrowserRouter 创建的URLhttp://example.com/some/path Router 会创建一个history对象，history用来跟踪URL，当URL发生变化时，Router的后代组件会重新渲染。ReactRouter 中提供的其他组件可以通过 context获取 history对象，ReactRouter 中其他组件必须作为Router组件的后代使用，但只能包含唯一一个子元素。12345678ReactDOM.render( return( &lt;BrowserRouter&gt; &lt;App /&gt; //&lt;App /&gt; &lt;/BrowserRouter&gt; ),document.getElementById('root')) 路由器每当有一个组件需要根据URL决定是否渲染时，就需要创建一个Route 匹配路径、挂载组件 1&lt;Route exact path='/home' component=&#123;Home&#125;/&gt; 1. path 当使用 BrowserRouter 时，path 用来描述这个Route 匹配的URL的pathname；当使用HashRouter 时，path 用来描述这个Route 匹配到的URL的 hash。当URL 匹配一个Route时，这个 Route中定义的组件就会被渲染出来。 2. match 当URL和Route匹配时，Route 会创建一个 match 对象作为props 中的一个属性传递给被渲染的组件，以下为对象包含的属性：（1）params：Route的path 可以包含参数，例如。params就是用于从匹配的URL中解析出 path 中的参数。例如，当 URL = ‘http://example.ocm/foo/1&#39; 时，params= {id: 1}。（2）isExact：布尔值，判断URL 是否完全匹配。例如，当 path=’/foo’、URL=”http://example.com/foo&quot; 时，是完全匹配; 当 URL=”http://example.com/foo/1&quot; 时，是部分匹配。（3）path：Route 的path 属性，构建嵌套路由时会使用到。（4）url：URL 的匹配的方式 3. Route 渲染组件的方式 （1）component component 的值是一个组件，当URL 和Route 匹配时，component属性定义的组件就会被渲染。 12&lt;Route path='/foo' component=&#123;foo&#125;/&gt;//当URL = 'http://example.com/foo'时，Foo 组件会被渲染 （2）render render 的值是一个函数，返回一个React 元素，并且可以为待渲染的组件传递额外的属性。 1234&lt;Route path='/foo' render=&#123;(props)=&gt;&#123; &lt;Foo &#123;...props&#125; data=&#123;extraProps&#125;/&gt; //Foo 组件接收一个额外的data 属性&#125;&#125;/&gt; （3）children children 的值是一个函数，返回要渲染的React 元素，但无论是否匹配成功，返回的组件都会被渲染。 4. Switch 和exact 当URL 和多个Route 匹配时，这些Route 都会被渲染，但如果只想让第一个匹配的Route 沉浸，可以把这些Route 放到一个Switch 组件中。如果想让URL 和Route 完全匹配时才渲染，可以使用Route 的exact 属性。 1234567&lt;Router&gt; &lt;Switch&gt; &lt;Route exact path='/' component=&#123;Home&#125;/&gt; &lt;Route exact path='/posts' component=&#123;Posts&#125; /&gt; &lt;Route exact path='/:user' component=&#123;User&#125; /&gt; &lt;/Switch&gt;&lt;/Router&gt;5. 嵌套路由是指在Route 渲染的组件内部再定义新的Route。 链接Link 是React Router提供的链接组件，当点击时，页面该跳转到哪个路由 123456&lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to='/'&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/post'&gt;Post&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/header&gt; 使用to 属性声明要导航到的URL 地址，当to 为object 类型时，可以包含pathname、search、hash、state四个属性。 1234567&lt;Link to=&#123;&#123; pathname: '/posts', search: '?sort=name', hash:'#the-hash', state: &#123; fromHome: true&#125;&#125;&#125;&gt;&lt;/Link&gt; 除了使用Link ，还可以使用history 对象手动实现导航。history 中的两个方法:push(path,[state])会向浏览器新增一条记录 和 replace(path,[state])会用新纪录替换记录。 12history.push('/posts');history.replace('/posts'); 动态路由 关于hooks和useEffect]]></content>
  </entry>
  <entry>
    <title><![CDATA[React笔记（三）-Virtual DOM]]></title>
    <url>%2F2019%2F10%2F16%2FReact%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-Virtual-DOM%2F</url>
    <content type="text"><![CDATA[一种编程的概念，是指虚拟的视图被保存在内存中，并通过诸如ReactDOM这样的库与真实的DOM保持同步，这一过程叫做Reconciliation 协调 差分算法（diff） 采用同级比对 比较不同类型的元素时，将删除旧元素并从零开始重构新元素 比较相同类型的ReactDOM元素时，则比较两者的属性，保持相同的底层DOM节点，并仅更新变化的属性 当组件更新时，实例保持相同，这样状态被维持。React 通过更新底层组件实例的属性(props)来匹配新元素 虚拟DOM 的比较一般都是在state发生变化时 setState 是异步的，可合并连续发生的state变化（setState 是异步的） 合理利用 key 属性提升性能]]></content>
  </entry>
  <entry>
    <title><![CDATA[React笔记（二）-Advanced Guides]]></title>
    <url>%2F2019%2F10%2F16%2FReact%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-Advanced-Guides%2F</url>
    <content type="text"><![CDATA[Context Context 提供了一种在组件之间共享此类值的方式，而不必显示地通过组件树的逐层传递 props 就是把context当作一个组件树内共享的store，用以传递数据。基于树形结构共享的数据：在某个节点开启提供context后，所有后代节点component都可以获得共享的数据 使用ContextContext的使用基于生产者消费者模式，即生产者（Provider）通常是一个父节点，消费者（Consumer）通常是一个或多个子节点。App.js 12345678910111213141516171819import React from 'react';import ReactDOM from 'react-dom';export const con = React.createContext()//通过静态方法React.createContext()创建Context对象，对象包含两个组件&lt;Provider /&gt; &lt;Consumer /&gt;export default class App extends Component &#123; render()&#123; return ( //使用一个Provider 将当前的值（dark）传递下去 &lt;Con.Provider value='dark'&gt; &lt;Toolbar /&gt; &lt;/Con.Provider&gt; ); &#125;&#125;function Toolbar (props)&#123; return ( &lt;Button/&gt; )&#125; 后代组件根据需要，指定contextType需要作用的组件树范围Child.js 1234567891011121314151617181920import React,&#123;Component&#125; from 'react';import &#123;con&#125; from './App'export default class Child extends Component&#123; //指定contextType读取当前的 value //react 会找到最近的value context 然后使用 static contextType = Con; render()&#123; return (&lt;Button theme=&#123;this.context&#125;/&gt;); //也可以使用&lt;Consumer&gt;组件指定消费者 // return ( // &lt;Con.Consumer&gt; // (value)=&gt;&lt;Button theme=&#123;value&#125;&gt; // &lt;/Con.Consumer&gt; // ) &#125;&#125;//除了写static contextType = Con; 也可以这样写Child.contextType = con; HOC HOC 就是一个函数，且该函数接收一个组件作为参数，并返回一个新组件 1234567891011121314151617181920212223242526272829303132333435363738394041import React,&#123;Component&#125; from 'react'export default class Hoc extends Component&#123; render()&#123; return ( &lt;div&gt; &lt;MyMusic /&gt; &lt;MyMusic1 /&gt; &lt;/div&gt; ) &#125;&#125;//实例化对象var MyMusic = hoc(Music,url,'one');function hoc(Com,url,title)&#123; class A extends Component&#123; constructor()&#123; super(); this.state=&#123; data:[] &#125; &#125; componentDidMount()&#123; Axios.get(url) .then((res)=&gt;&#123; this.setState(&#123; data:res.data.result &#125;) console.log(res); &#125;) &#125; render()&#123; return( &lt;div&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;Com data=&#123;this.state.data&#125;&gt; &lt;/div&gt; ) &#125; &#125;&#125; Portals Portals提供了一种能让子节点渲染到父组件之外的方式 123ReactDOM.createPortal(child,container);//child 是任何可渲染的React子元素//container 是一个DOM元素 当父组件有overflow:hidden / z-index时，需要子组件能够在视觉上跳出容器时使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（五）-net模块]]></title>
    <url>%2F2019%2F10%2F14%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-net%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[服务器和客户端之间的交互关于数据交互，可以想象成，server和client之间建立了一个pipe，pipe有两个分支，一个用于发送 s 到 c 的数据，一个用于发送 c 到 s 的数据。server会监听端口，而client去访问端口，在Unix/Linux中，也可以监听文件。 node如何开启一个 TCP 服务器 TCP全名为传输控制协议，在OSI模型中属于传输层协议 创建TCP服务器端123456789101112131415var net = require('net');var server = net.createServer(function(socket)&#123; socket.on('data',function(data)&#123; socket.write('hello'); &#125;); socket.on('end',function()&#123; console.log('connected filed'); &#125;);&#125;);server.listen(8080,function()&#123; console.log('server bound');&#125;); 使用telnet 192.168.91.144 8080作为客户端对刚才创建的简单服务器进行会话交流 TCP服务的事件 服务器事件 listening：通过server.listen(port,listeningListener)，第二个参数传入 connection：通过net.createServer()，最后一个参数传递 close error 连接事件 data end connect drain error close timeout 构建UDP服务 在UDP中，一个套接字可以与多个UDP服务通信，特点：面向事务提供简单的不可靠信息传输服务，但无须连接，资源消耗低，处理快速灵活。 创建UDP服务器端1234567891011121314//创建UDP套接字const dgram = require('dgram');var socket = dgram.createSocket('udp4');socket.bind(8080);//绑定端口socket.on('message',(msg)=&gt;&#123; var line = msg.toString('utf-8'); process.stdout.write(line,line.length);&#125;);socket.on('listening',()=&gt;&#123; console.log('server ready: ',socket.address());&#125;); 创建UDP客户端调用send()方法发送消息到网络中，socket.send(buf, offset, length, port, address, [callback]) 123456789const dgram = require('dgram'), socket = dgram.createSocket('udp4');var host = process.argv[2];var port = process.argv[3];process.stdin.on('data',(data)=&gt;&#123; var line = data.toString('utf-8'); socket.send(line,0,line.length,port,host);&#125;); UDP套接字事件 message：接收到消息时触发该事件 listening：当UDP套接字开始侦听时触发该事件 close error]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（四）-子进程]]></title>
    <url>%2F2019%2F10%2F14%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%AD%90%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[node中的单线程和单进程首先回顾一下，node是一个基于Chrome V8引擎的JavaScript运行环境。node使用事件驱动，非阻塞I/O的模型。 我们所说的单线程是指node中只有一个js引擎在主线程上运行，其他异步IO和事件驱动相关的线程通过libuv实现内部的线程池和线程调度。 进程是资源分配的基本单位，线程是任务调度和执行的基本单位 event loop就是维持一个执行栈和一个事件队列，当前执行栈中的如果发现异步IO以及定时器等函数，就会把这些异步回调函数放到事件队列中，当前执行栈执行完后，从事件队列中，按照一定的顺序执行回调函数。 node中的 child_process 模块实现多进程通过child_process模块，可以实现一个主进程，多个子进程的模式，主进程成为master进程，子进程又称为工作进程。 在子进程中不仅可以调用其他node程序，也可以执行非node程序以及shell命令，执行完子进程后，以流或者回调的形式返回 child_process 模块提供的APIchild_process 提供的4个方法（异步） spawn：子进程中执行的非node程序，提供一组参数后，执行结果以流的形式返回。 execFile：子进程中执行的非node程序，提供一组参数后，执行结果以回调的形式返回。 exec：子进程中执行的非node程序，传入一串shell命令，执行后结果以回调的形式返回。 fork：子进程执行的是node程序，提供一组参数后，执行后结果以流的形式返回。 execFile 和 exec 相同点：执行的都是非node程序，且执行后的结果都以回调的形式返回。 不同点：exec是执行一段shell命令，而execFile是执行一个应用。 通过exec实现 1234let cp = require('child_process');//引入child_process模块cp.exec('echo hello world',function(err,stdout)&#123; console.log(stdout);&#125;); 执行文件，输出hello world，exec的第一个参数，和shell命令完全相似 通过execFile实现 1234let cp = require('child_process');cp.execFile('echo',['hello','world'],function(err,stdout)&#123; console.log(stdout);&#125;); execFile会在process.env.PATH的路径中依次寻找是否有’echo’的应用，找到后就会执行。&#39;echo&#39;程序存在&#39;usr/local/bin&#39;目录中，传入hello和world两个参数，执行后返回。 安全性分析exec 直接执行一段shell是极为不安全的；而execFile会检测传入实参执行的安全性，如果存在安全性问题，会抛出异常，安全性较高。 spawnspawn用于执行非node应用，且不能直接执行shell，与execFile相比，spawn执行应用后并不是一次性输出的，而是以流的形式输出，可以明显减少内存的占用。 12345678910let cp = require('child_process');let cat = cp.spawn('cat',['input.txt']);let sort = cp.spawn('sort');let uniq = cp.spawn('uniq');cat.stdout.pipe(sort.stdin);//读取input.txt中的内容sort.stdout.pipe(uniq.stdin);//sort程序实现排序功能uniq.stdout.pipe(process.stdout);//uniq程序实现去重console.log(process.stdout); fork在node中使用内置于父进程和子进程之间的通信来处理大量计算的任务，从而降低大数据运行的压力。通过fork方法在单独的进程中执行node程序，并且通过父子间的通信，子进程接受父进程的信息，并将执行后的结果返回给父进程。使用fork方法可以在父进程和子进程之间开发一个IPC通道，使不同的node进程间可以进行消息通信。 在child.js中： 123process.on('message',function(msg)&#123; process.send(msg);&#125;) 在parent.js中： 1234567891011let cp = require('child_process');let child = cp.fork('./child');child.on('message',function(msg)&#123; console.log('got a message is',msg);&#125;);child.send('hello world');//got a message is hello world//在父进程中调用，中断父子间通信child.disconnect()]]></content>
  </entry>
  <entry>
    <title><![CDATA[React笔记（一）]]></title>
    <url>%2F2019%2F10%2F08%2FReact%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[定义 react 是一个用于构建用户界面的JavaScript库 react 主要用于构建UI，很多人认为是MVC中的V MVC即 模型 (moudel) - 视图 (view) - 控制器 (controller) 特点 组件：通过 react 构建组件，使得代码更加容易得到复用 JSX：是JavaScript 语法的扩展 单向相应的数据流：从而减少了重复代码 灵活：react 可以和已知的库或框架配合 高效：react 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互 声明式设计：react 采用声明范式，可以轻松描述应用 React 元素渲染 元素是构成React 应用的最小单位，用于描述屏幕上输出的内容 1const ele = &lt;h1&gt;hello,world&lt;/h1&gt;; 将元素渲染到 DOM 中123//在HTML页面中添加一个id = 'example' 的 &lt;div&gt;&lt;div id='example'&gt;&lt;/div&gt;//在此 div 中的所有内容都将由 React DOM 来管理，称为 “根DOM” 结点 在用 React 开发应用时一般只会定义一个根节点 更新元素渲染 React 元素是不可变的 React 元素被创建后，无法改变其内容和属性 更新界面的唯一办法是创建一个新元素，然后传入 ReactDOM.render()方法12345function tick()&#123; const ele = &lt;div&gt;&#123;new Date().toLocalTimeString()&#125;&lt;/div&gt;; ReactDOM.render(ele, document.getElementById('example'));&#125;setInterval(tick,1000); 封装到函数中 123456789101112131415function Clock(props)&#123; return ( &lt;div&gt; &lt;h1&gt;hello,world&lt;/h1&gt; &lt;h2&gt;现在时间：&#123;props.date.toLocalTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; )&#125;function tick()&#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125;/&gt;, document.getElementById('root') );&#125;setInterval(tick,1000); 除函数外，还可以封装成 ES6类，另外在 render() 中需要用this.props 替换 props; 1234567891011121314151617class Clock extends React.Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;hello,world&lt;/h1&gt; &lt;h2&gt;现在时间：&#123;this.props.date.toLocalTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;function tick()&#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125;/&gt;, document.getElementById('root') );&#125;setInterval(tick,1000); JSX 语法 React 使用JSX 替代常规的JavaScript 利用HTML语法来创建虚拟 DOM JSX 是在 JavaScript内部实现的1234const ele = &lt;h1&gt;hello,world&lt;/h1&gt;;//JSXvar myDivEle = &lt;div className = 'foo'/&gt;;ReactDOM.render(myDivEle,document.getElementById('example')); React 当中的元素是普通的对象，ReactDOM 可以确保浏览器DOM 的数据内容与 React 元素保持一致通过 ReactDOM.render() 方法将元素渲染到页面上 使用 JSX1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;JSX&lt;/h1&gt; &lt;p data-myattribute="somevalue"&gt;React 是一个用于构建用户界面的JavaScript库&lt;/p&gt; &lt;/div&gt; ,document.getElementById('example');) 可以将 JSX 代码放在独立的文件中，在HTML中引入 1234&lt;body&gt; &lt;div id = "example"&gt;&lt;/div&gt; &lt;script type="text/babel" src="react.js"&gt;&lt;/script&gt;&lt;/body&gt; js表达式JSX 中的JavaScript表达式需要写在 {}中 123456ReactDOM.render( &lt;div&gt; &lt;h1&gt;&#123;i == 1 ? 'true' : 'false'&#125;&lt;/h1&gt; &lt;/div&gt; ,document.getElementById('example');) 样式React 推荐使用内联样式(React 会在指定元素数字后自动添加 px) 12345678var myStyle = &#123; fontSize : 100, color : 'black'&#125;;ReactDOM.render( &lt;h1 style=&#123;myStyle&#125;&gt;hello,world&lt;/h1&gt;, document.getElementById('example')); 注释12345ReactDOM.render( &lt;h1&gt;hello,world&lt;/h1&gt; &#123;/*注释。。。*/&#125;, document.getElementById('example')); 数组在模版中插入数组，数组会自动展开所有成员 12345678var arr = [ &lt;h1&gt;1111&lt;/h1&gt;, &lt;h2&gt;222&lt;/h2&gt;];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example')); React 组件定义React组件的三种方式： 函数式定义的 无状态组件 es5原生方式 React.createClass 定义的组件 es6形式的 extends React.Component 定义的组件无状态函数式组件 接收单一的props对象，返回一个React元素 props 是组件的输入内容，从父组件传递给子组件的数据（属性） props 是只读的；组件名必须以大写字母开头1234567function HelloComponent(props)&#123; return ( &lt;div&gt;hello,&#123;props.name&#125;&lt;/div&gt; )&#125;ReactDOM.render( &lt;HelloComponent name="React"/&gt;,document.getElementById('root')); es5原生方式12345const MyComponent = React.createClass(&#123; render : function()&#123; return &lt;h1&gt;mycomponent&lt;/h1&gt; &#125;&#125;) es6中class类的方式123456789101112131415class MyComponent extends React.Component&#123; constructor()&#123; super(); this.state = &#123; // todo:[1,2,3] &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;hello,world&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; State(状态) 私有的，完全受控于当前组件，组件外部无法进行修改 类定义的组件特有的属性，函数定义的组件无state 构造函数是唯一能初始化this.state的地方12345678910111213class Hello extends React.Component&#123; constructor()&#123; super(); this.state=&#123; name:'React' &#125; &#125; render()&#123; return( &lt;h1&gt;Hello,&#123;this.state.name&#125;&lt;/h1&gt; ) &#125;&#125; 组件的生命周期 只有类定义的组件中才有生命周期函数，函数方式定义的没有 生命周期函数：在某一时刻组件会自动执行的函数 声明周期包含的阶段 初始化 挂载 更新 卸载 错误 初始化 (initialization) constructor() 1234567891011import React,&#123;Component&#125; from 'react';class Test extends Component&#123; //在装载之前被调用 //在函数内应在其他表达式之前调用super(props)，否则this.props在构造函数中是未定义的 constructor(props)&#123; super(props);//调用基类的构造方法，也将父组件的props注入给子组件 this.state = &#123; todo : 'hello' &#125; &#125;&#125; 作用： 初始化状态，通过赋值一个对象到 this.state 绑定事件处理函数到一个实例 挂载 (mounting) static getDerivedStateFromProps()在组件实例化后或接收新属性时会被调用 render()根据组件的props和state，return一个React元素；不负责组件的实际渲染工作 componentDidMount()组件挂载后立即调用，发送请求的好地方？？ 更新 (update)造成组件更新的情况可以看这篇 static getDerivedStateFromProps() shouldComponentUpdate() 在接收到新属性或状态时，在渲染前被调用，返回布尔值 render() getSnapshotBeforeUpdate() 在最新的渲染输出提交给DOM前将会被立即调用 该函数返回的任何值将会 作为参数传递给 componentDidUpdate componentDidUpdate() 卸载 componentWillUnmount() 用于清除组件中使用的定时器错误处理 componentDidCatch() 事件处理事件绑定 React 事件绑定属性的命名采用驼峰式写法 采用JSX语法，需传入一个函数作为事件处理函数，而不是字符串（DOM元素的写法） 调用e.preventDefault()阻止组件的默认行为123456789101112131415161718192021class Click extends React.Component&#123; constructor()&#123; super(); this.state = &#123; context : 'hello' &#125; &#125; handleClick = ()=&gt;&#123; console.log(this); this.setState(&#123;context : 'world'&#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.state.context&#125;&lt;/p&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;click&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Click /&gt;,document.getElementById('root')); this 事件处理函数传参]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件系统]]></title>
    <url>%2F2019%2F09%2F29%2F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[fs 模块1const fs = require('fs');//引入模块 fs 模块中的方法均有同步和异步版本，异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含错误信息（error） 建议使用异步的方法，比同步方法性能更高，速度更快，而且没有阻塞。 打开文件12fs.open(path, flags[,mode], callback(err, fd))//文件路径， 文件打开的行为， 设置文件模式， 回调函数 123456789var fs = require('fs');console.log('准备打开文件');fs.open('input.txt',function(err,fd)&#123; if(err)&#123; return console.log(err); &#125; console.log('文件打开成功');&#125;) 获取文件信息12345678fs.stat(path, callback(err, stats))//path 文件路径//stats 是fs.stats对象var fs = require('fs');fs.stat('path', function(err, stats)&#123; console.log(stats.isFile());&#125;) stats类中的方法 描述 stats.isFile() 判断是否为文件 stats.isDirectory() 判断是否为目录 stats.isSymbolicLink() 判断是否为软链接 12345678910var fs = require('fs');fs.stat('test.js', function(err, stats)&#123; if(err)&#123; return console.error(err); &#125; console.log(stats); console.log('读取文件成功'); console.log('是否为文件：'+stats.isFile());&#125;); 写入文件1234567891011121314fs.writeFile(file,data[, options],callback(err))//如果文件存在，该方法写入的内容会覆盖旧的文件内容var fs = require('fs');fs.writeFile('test.js','想要写入的内容', function(err)&#123; if(err)&#123; return console.error(err); &#125; console.log('写入成功'); fs.readFile('test.js', function(err,data)&#123; if(err) return console.error(err); console.log('异步读取文件数据'+data.toString()); &#125;);&#125;) 读取文件12fs.read(fd, buffer, offset, length, position, callback)//使用文件描述符来读取文件 参数 fd 通过 fs.open() 返回的文件描述符 buffer 数据写入的缓冲区 offset 缓冲区写入的写入偏移量 length 要从文件中读取的字节数 position 文件读取的起始位置 callback(err, bytesRead, buffer) bytesRead表示要读取的字节数，buffer为缓冲区对象 12345678910111213141516var fs = require('fs');var buf = new Buffer.alloc(1024);fs.open('test.js','r+',function(err,fd)&#123; if(err)&#123; return console.error(err); &#125; fs.read(fd,buf,0,buf.length,0,function(err,bytes)&#123; if(err) return console.error(err); console.log(bytes + '字节被读取'); if(bytes &gt; 0)&#123; console.log(buf.slice(0,bytes).toString()); &#125; &#125;);&#125;); 关闭文件123fs.close(fd, callback())//fd 通过 fs.open()返回的文件描述符//callback 无参 123456789101112131415var fs = require('fs');var buf = new Buffer.alloc(1024);fs.open('test.js','r+',function(err,fd)&#123; if(err) console.error(err); fs.read(fd,buf,0,buf.length,0,function(err,bytes)&#123; if(err) console.error(err); if(bytes &gt; 0) console.log(buf.slice(0,bytes).toString()); fs.close(fd,function(err)&#123; if(err) console.error(err); console.log('文件关闭成功'); &#125;); &#125;);&#125;); 创建目录1234567891011fs.mkdir(path[, options],callback())//options的参数：// recursive-以递归的方式创建目录// mode-设置目录权限var fs = require('fs'), dir = process.argvs[2] || __dirname;fs.mkdir(dir, function(err)&#123; if(err) console.error(err);&#125;); 读取目录123456789101112fs.readdir(path,callback)//path//callback(err, files) files为目录下的文件数组列表var fs = require('fs');fs.readdir("/tmp/",function(err,files)&#123; if(err) console.error(err); files.forEach(function(files)&#123; console.log(file); &#125;);&#125;); 删除目录1fs.rmdir(path,callback)]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F09%2F29%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[构建HTTP服务简单的HTTP服务器 123456var http = require('http');http.createServer((req,res)=&gt;&#123; res.writeHead(200,&#123;'Content-Type':'text/plain'&#125;); res.end('hello world\n');&#125;).listen(8080); HTTP HTTP 全称超文本传输协议（HyperText Transfer Protocol）]]></content>
  </entry>
  <entry>
    <title><![CDATA[我和小萌的lovelog]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%88%91%E5%92%8C%E5%B0%8F%E8%90%8C%E7%9A%84lovelog%2F</url>
    <content type="text"><![CDATA[春夏秋冬，你若在场，就很美好]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（三）]]></title>
    <url>%2F2019%2F09%2F22%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[流 stream流是什么 流是数据的集合，在操作大量数据或数据从外部逐段发送过来的时候变得非常有用 可以像通过管道连接linux命令一样，通过pipe组合功能 所有的流都是 EventEmitter 的实例， 使用流pipe方法 使用管道的方式将流连接起来 将可读流的输出连接到可写流的输入，管道的source必须是可读流，destination必须是可写流 1readableSrc.pipe(writableDest); 也可以是双工流/转换流 1readableSrc.pipe(transformStream1).pipe(transformStream2).pipe(finalWritableDest) 流事件（更自定义的方式使用流） 直接通过事件读取，模拟pipe的读取、写入 12345678//readable.pipe(writable)readable.on('data',(chunk)=&gt;&#123; writable.write(chunk);&#125;);readable.on('end',()=&gt;&#123; writable.end();&#125;); 可读流、可写流的事件和方法 Readable Streams的两个重要事件 data 事件，当可读流发送数据给消费者时，会触发 end 事件，可读流数据发送完成时触发 Writeable Streams的两个重要事件 drain 事件，表示可写流可以接收更多数据的信号 finish 事件，当所有数据都被写入底层系统后会触发 可读流的暂停和流动模式可读流的两种模式：暂停模式、流动模式（或拉取模式、推送模式） 所有可读流默认处于暂停模式，可以使用 read() 方法读取数据 当可读流处于流动模式时，需要通过事件监听来处理数据 增加一个 data 事件回调可以把处于暂停模式的流切换到流动模式，同样移除 data 事件回调会把流切换到暂停模式 可以使用 resume() 和 pause() 方法手动在两个模式间切换 实现流实现可写流1const &#123;Writable&#125; = require('streams'); 例如可以继承 Writable 类 12class myWritableStream extends Writable&#123;&#125; 或者，直接给 Writable 构造函数传入配置项来创建一个对象 123456789const &#123;Writable&#125; = require('stream');const outStream = new Writable(&#123; write(chunk, encoding, callback)&#123; console.log(chunk.toString()); callback(); &#125;&#125;);process.stdin.pipe(outStream); 关于 write() 的三个参数： chunk 通常是一个buffer encoding 通常可以忽略，除非 chunk 被配置为不是buffer callback 方法是完成数据处理后要执行的回调函数，用来表示数据能否成功写入，若写入失败，在执行该回调函数时要传入一个错误对象。 实现可读流引入 Readable 接口并通过它创建对象： 1234567891011const &#123;Readable&#125; = require('stream');const inStream = new Readable(&#123;&#125;);//使用 push方法向下游推送数据inStream.push('abcdce');inStream.push('dfslafsa');//当 push一个 null值时，表示后续不会再有数据了inStream.push(null);inStream.pipe(process.stdout); 实现双工/转换流双工流就是要在同一个对象上同时实现可读流和可写流 1234567891011121314151617const &#123;Duplex&#125; = require('stream');const inoutStream = new Duplex(&#123; write(chunk, encoding,callback)&#123; console.log(chunk.toString()); callback(); &#125;, read(size)&#123; this.push(String.fromCharCode(this.currentCharCode++)); if(this.currentCharCode &gt; 90)&#123; this.push(null); &#125; &#125;&#125;);inoutStream.currentCharCode = 65;process.stdin.pipe(inoutStream).pipe(process.stdout); 转换流的 transform 方法 12345678910const &#123;Transform&#125; = require('stream');const upperCaseTr = new Transform(&#123; transform(chunk, encoding, callback)&#123; this.push(chunk.toString().toUpperCase()); callback(); &#125;&#125;);process.stdin.pipe(upperCaseTr).pipe(process.stdout);]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（二）]]></title>
    <url>%2F2019%2F09%2F21%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[事件所有的异步I/O操作在完成时都会发送一个事件到事件队列；许多对象都会分发事件，所有这些产生事件的对象都是 events.EventEmitter 的实例 例如fs.readStream对象会在文件被打开的时候触发一个事件 EventEmitter 类 核心：事件触发与事件监听器功能的封装 event对象注册了事件some_event 的监听器，通过setTimeout在1s后向event对象发送事件some_event，此时会调用监听器 1234567891011const EventEmitter = require('events').EventEmitter;var event = new EventEmitter();event.on('some_event',function()&#123; console.log('s_e 事件触发');&#125;);setTimeout(function()&#123; event.emit('some_event');&#125;,1000);//1s后//s_e 事件触发 EventEmitter 的每个事件由一个事件名和若干个参数组成，且EventEmitter 支持若干个事件监听器 当事件被触发时，监听器被依次调用，事件参数作为回调函数参数传递 12345678910111213const events = require('events');var e = new events.EventEmitter();e.on('some_event',function(arg1,arg2)&#123; console.log('listener1',arg1,arg2);&#125;);e.on('some_event',function(arg1,arg2)&#123; console.log('listener2',arg1,arg2);&#125;);e.emit('some_event','arg1 参数','arg2 参数');//listener1 arg1 参数 arg2 参数//listener2 arg1 参数 arg2 参数 on 用于绑定事件函数，emit 用于触发一个事件 方法 on(event,listener)为指定事件注册监听器，接收一个字符串event和一个回调函数 123server.on('connection',function(stream)&#123; console.log('someone connected');&#125;); addListener(event,listener)为指定事件添加一个监听器到监听器数组的尾部 once(event,listener)为指定事件注册一个单次监听器，最多触发一次，触发后立即解除 123server.once('connection',function(stream)&#123; console.log('once');&#125;); emit(event,[arg1],[arg2],[…])按监听器的顺序执行，如果事件有注册监听返回true removeListener(event,listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器，第一个参数是事件名称，第二个是回调函数 12345var callback = function(stream)&#123; console.log('some connected');&#125;;server.on('connection',callback);server.removeListener('connection',callback); 类方法 listenerCount(emitter,event)返回指定事件的监听器数量1events.emitter.listenerCount(eventName) 事件 newListener在添加新监听器时被触发 removeListener从指定监听器数组中删除一个监听器 12345678910111213141516171819202122232425262728293031var events = require('events');var eventEmitter = new events.EventEmitter();//监听器var listener1 = function listener1()&#123; console.log('监听器 listener1执行');&#125;var listener2 = function listener2()&#123; console.log('监听器 listener2执行');&#125;//绑定connection事件，处理函数为listenereventEmitter.addListener('connection',listener1);eventEmitter.on('connection',listener2);//打印监听器数量var eventListeners = eventEmitter.listenerCount('connection');console.log(eventListeners+"个监听器监听连接事件");//处理connection事件eventEmitter.emit('connection');//移除绑定的 listener1 函数eventEmitter.removeListener('connection',listener1);console.log('listener1 不再受监听');//触发连接事件eventEmitter.emit('connection');eventListeners = eventEmitter.listenerCount('connection');console.log(eventListeners+"个监听器监听连接事件");console.log('over'); 1234567//2 个监听器监听连接事件//监听器listener1 执行//监听器listener2 执行//listener1 不再受监听//监听器listener2 执行//1 个监听器监听连接事件//over 继承EventEmitter类 原型继承EventEmitter类 12345678910111213141516171819202122232425const EventEmitter = require('events').EventEmitter;function Dog(name,energy)&#123; var _name,_energy; var that = this; EventEmitter.call(this); _name = name; _energy = energy; //定时器 var timer = setInterval(()=&gt;&#123; if(_energy &gt; 0)&#123; that.emit('bark'); _energy--; &#125;else&#123; clearInterval(timer); &#125; &#125;,1000); this.getName = ()=&gt;_name; this.getEnergy = ()=&gt;_energy;&#125;Dog.prototype = EventEmitter.prototype;module.exports = Dog;//导出模块 123456789101112const Dog = require('./02-dog.js');//引入模块//实例化对象var taidi = new Dog('taidi',4);var zangao = new Dog('zangao',10);taidi.on('bark',onBark);//触发事件zangao.on('bark',onBark);function onBark()&#123; console.log('%s barked. energy:%s',this.getName(),this.getEnergy());&#125;]]></content>
      <tags>
        <tag>nodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（一）]]></title>
    <url>%2F2019%2F09%2F02%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[nodejs是一个基于chrome v8引擎的JavaScript运行环境 仅使用一个线程 non-blocking I/O 非阻塞 一个线程永远在执行计算操作 event-driven 事件驱动 一些在centeOS中的常用命令 ls 查看当前目录 cd .. 切换到上级目录 mkdir 创建文件夹 touch file 新建文件 vim file 使用vim编辑文件 :wq 保存退出 :w 仅保存 http 内置模块123456const http = require('http');//引入http模块http.createServer((req,res)=&gt;&#123;//创建服务//req请求对象，res响应对象 res.end('hello world');//结束响应&#125;).listen(8080);//通过8080端口监听 全局获取命令行参数 123var arg = process.argv[];//process是全局对象，argv返回一个包含命令行参数的数组//第一个元素是'node'，第二个元素是文件名，接下来是命令行参数 当前进程的PID [ process.pid ] 退出码 [ process.exit(code) ] 输入输出流 [ process.stdout ] 12process.stdout.write('hello world');//指向标准输出流的可写的流(writable stream) [ process.stdin ] 1234567891011121314process.stdin.resume();var a,b;process.stdout.write('请输入a:');process.stdin.on('data',function(data)&#123; if(a == undefined)&#123; a = Number(data); process.stdout.write('请输入b：'); &#125;else&#123; b = Number(data); process.stdout.write('结果：'+ (a+b)); process.exit(); &#125;&#125;);//一个指向标准输入流的可读流（readable stream），标准输入流默认是暂停的，所以b必须调用process.stdin.resume()来恢复接收 [ process.stderr ] 12process.stderr.write('输出标出错误流');//一个指向标准错误流的可写的流（writable stream） 处理信号量 接收信号量，并对（SIGINT 和 SIGSTP）进行处理 123process.on('SIGINT',function()&#123; console.log('Got SIGINT. Press Control-D to exit.');&#125;) 六个定时器函数1234567891011setTimeout(()=&gt;console.log(1));setImmediate(()=&gt;console.log(2));process.nextTick(()=&gt;console.log(3));Promise.resolve().then(()=&gt;console.log(4));(()=&gt;console.log(5))();//立即执行函数//5//3//4//1//2 同步任务比异步任务更早执行 异步任务又分为两种： 追加在本轮循环（event loop）的异步任务 追加在次轮循环的异步任务 本轮循环一定早于次轮循环执行 process.nextTick() 和 Promise的回调函数追加在本轮循环；setTimeout、setInterval、setImmediate的回调函数追加在次轮循环 [ setTimeout() ] [ setInterval() ] [ setImmediate() ] [ process.nextTick() ]]]></content>
      <tags>
        <tag>nodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[”零基础向搭建个人博客]]></title>
    <url>%2F2019%2F07%2F11%2F%E2%80%9D%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%90%91%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[首先要选择blog的框架 hexo 插件多，所以选了从这个开始入手 hugo 编译性能较好 jekyll 迁移和部署较方便 安装hexo安装 node.js 常用命令123npm install -g hexo //安装hexohexo init //初始化hexo //确认是否安装成功 安装 git 通过GitHub Pages部署到服务器]]></content>
  </entry>
  <entry>
    <title><![CDATA[test_one]]></title>
    <url>%2F2019%2F07%2F10%2Ftest-one%2F</url>
    <content type="text"><![CDATA[HTML构建页面的结构、CSS代码描述页面样式、JavaScript代码设计页面行为（动态特效）JavaScript是一种基于 对象 和 事件驱动 并具有安全性能的脚本语言。 123&lt;script type=&quot;text/javascript&quot;&gt; alert(&apos;hello javascript&apos;);&lt;/script&gt; 在浏览器中弹出一个提醒框 JavaScript是一种基于 对象 和 事件驱动 并具有安全性能的脚本语言。 &emsp;Java是一种面向对象的程序开发语言，需要“编译-链接-运行”&emsp;JavaScript只需经过“编写-运行” -特点:不用给变量指定数据类型（动态类型）、一个变量可以赋不同类型的值（弱类型）、解释性语言不需要编译，方便调试（简单性）、依赖浏览器本身，与操作环境无关（跨平台性）、主流浏览器统一支持的语言（必要性）、兼容性差 原始数据类型–Number、String、Boolean、Undefined、Null–使用 typeof 运算符，判断变量在某一时刻的数据类型–弱类型是指不同类型的变量之间可以相互赋值，但在某一时刻，一个变量只存在某一种数据类型]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
