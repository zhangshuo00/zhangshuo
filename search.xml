<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nodeJs笔记（五）-net模块]]></title>
    <url>%2F2019%2F10%2F14%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-net%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[服务器和客户端之间的交互关于数据交互，可以想象成，server和client之间建立了一个pipe，pipe有两个分支，一个用于发送 s 到 c 的数据，一个用于发送 c 到 s 的数据。server会监听端口，而client去访问端口，在Unix/Linux中，也可以监听文件。 node如何开启一个 TCP 服务器 TCP全名为传输控制协议，在OSI模型中属于传输层协议 创建TCP服务器端123456789101112131415var net = require('net');var server = net.createServer(function(socket)&#123; socket.on('data',function(data)&#123; socket.write('hello'); &#125;); socket.on('end',function()&#123; console.log('connected filed'); &#125;);&#125;);server.listen(8080,function()&#123; console.log('server bound');&#125;); 使用telnet 192.168.91.144 8080作为客户端对刚才创建的简单服务器进行会话交流 TCP服务的事件 服务器事件 listening：通过server.listen(port,listeningListener)，第二个参数传入 connection：通过net.createServer()，最后一个参数传递 close error 连接事件 data end connect drain error close timeout 构建UDP服务 在UDP中，一个套接字可以与多个UDP服务通信，特点：面向事务提供简单的不可靠信息传输服务，但无须连接，资源消耗低，处理快速灵活。 创建UDP服务器端1234567891011121314//创建UDP套接字const dgram = require('dgram');var socket = dgram.createSocket('udp4');socket.bind(8080);//绑定端口socket.on('message',(msg)=&gt;&#123; var line = msg.toString('utf-8'); process.stdout.write(line,line.length);&#125;);socket.on('listening',()=&gt;&#123; console.log('server ready: ',socket.address());&#125;); 创建UDP客户端调用send()方法发送消息到网络中，socket.send(buf, offset, length, port, address, [callback]) 123456789const dgram = require('dgram'), socket = dgram.createSocket('udp4');var host = process.argv[2];var port = process.argv[3];process.stdin.on('data',(data)=&gt;&#123; var line = data.toString('utf-8'); socket.send(line,0,line.length,port,host);&#125;); UDP套接字事件 message：接收到消息时触发该事件 listening：当UDP套接字开始侦听时触发该事件 close error]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（四）-子进程]]></title>
    <url>%2F2019%2F10%2F14%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%AD%90%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[node中的单线程和单进程首先回顾一下，node是一个基于Chrome V8引擎的JavaScript运行环境。node使用事件驱动，非阻塞I/O的模型。 我们所说的单线程是指node中只有一个js引擎在主线程上运行，其他异步IO和事件驱动相关的线程通过libuv实现内部的线程池和线程调度。 进程是资源分配的基本单位，线程是任务调度和执行的基本单位 event loop就是维持一个执行栈和一个事件队列，当前执行栈中的如果发现异步IO以及定时器等函数，就会把这些异步回调函数放到事件队列中，当前执行栈执行完后，从事件队列中，按照一定的顺序执行回调函数。 node中的 child_process 模块实现多进程通过child_process模块，可以实现一个主进程，多个子进程的模式，主进程成为master进程，子进程又称为工作进程。 在子进程中不仅可以调用其他node程序，也可以执行非node程序以及shell命令，执行完子进程后，以流或者回调的形式返回 child_process 模块提供的APIchild_process 提供的4个方法（异步） spawn：子进程中执行的非node程序，提供一组参数后，执行结果以流的形式返回。 execFile：子进程中执行的非node程序，提供一组参数后，执行结果以回调的形式返回。 exec：子进程中执行的非node程序，传入一串shell命令，执行后结果以回调的形式返回。 fork：子进程执行的是node程序，提供一组参数后，执行后结果以流的形式返回。 execFile 和 exec 相同点：执行的都是非node程序，且执行后的结果都以回调的形式返回。 不同点：exec是执行一段shell命令，而execFile是执行一个应用。 通过exec实现 1234let cp = require('child_process');//引入child_process模块cp.exec('echo hello world',function(err,stdout)&#123; console.log(stdout);&#125;); 执行文件，输出hello world，exec的第一个参数，和shell命令完全相似 通过execFile实现 1234let cp = require('child_process');cp.execFile('echo',['hello','world'],function(err,stdout)&#123; console.log(stdout);&#125;); execFile会在process.env.PATH的路径中依次寻找是否有’echo’的应用，找到后就会执行。&#39;echo&#39;程序存在&#39;usr/local/bin&#39;目录中，传入hello和world两个参数，执行后返回。 安全性分析exec 直接执行一段shell是极为不安全的；而execFile会检测传入实参执行的安全性，如果存在安全性问题，会抛出异常，安全性较高。 spawnspawn用于执行非node应用，且不能直接执行shell，与execFile相比，spawn执行应用后并不是一次性输出的，而是以流的形式输出，可以明显减少内存的占用。 12345678910let cp = require('child_process');let cat = cp.spawn('cat',['input.txt']);let sort = cp.spawn('sort');let uniq = cp.spawn('uniq');cat.stdout.pipe(sort.stdin);//读取input.txt中的内容sort.stdout.pipe(uniq.stdin);//sort程序实现排序功能uniq.stdout.pipe(process.stdout);//uniq程序实现去重console.log(process.stdout); fork在node中使用内置于父进程和子进程之间的通信来处理大量计算的任务，从而降低大数据运行的压力。通过fork方法在单独的进程中执行node程序，并且通过父子间的通信，子进程接受父进程的信息，并将执行后的结果返回给父进程。使用fork方法可以在父进程和子进程之间开发一个IPC通道，使不同的node进程间可以进行消息通信。 在child.js中： 123process.on('message',function(msg)&#123; process.send(msg);&#125;) 在parent.js中： 1234567891011let cp = require('child_process');let child = cp.fork('./child');child.on('message',function(msg)&#123; console.log('got a message is',msg);&#125;);child.send('hello world');//got a message is hello world//在父进程中调用，中断父子间通信child.disconnect()]]></content>
  </entry>
  <entry>
    <title><![CDATA[React笔记（一）]]></title>
    <url>%2F2019%2F10%2F08%2FReact%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[定义 react 是一个用于构建用户界面的JavaScript库 react 主要用于构建UI，很多人认为是MVC中的V MVC即 模型 (moudel) - 视图 (view) - 控制器 (controller) 特点 组件：通过 react 构建组件，使得代码更加容易得到复用 JSX：是JavaScript 语法的扩展 单向相应的数据流：从而减少了重复代码 灵活：react 可以和已知的库或框架配合 高效：react 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互 声明式设计：react 采用声明范式，可以轻松描述应用 React 元素渲染 元素是构成React 应用的最小单位，用于描述屏幕上输出的内容 1const ele = &lt;h1&gt;hello,world&lt;/h1&gt;; 将元素渲染到 DOM 中123//在HTML页面中添加一个id = 'example' 的 &lt;div&gt;&lt;div id='example'&gt;&lt;/div&gt;//在此 div 中的所有内容都将由 React DOM 来管理，称为 “根DOM” 结点 在用 React 开发应用时一般只会定义一个根节点 更新元素渲染 React 元素是不可变的 React 元素被创建后，无法改变其内容和属性 更新界面的唯一办法是创建一个新元素，然后传入 ReactDOM.render()方法12345function tick()&#123; const ele = &lt;div&gt;&#123;new Date().toLocalTimeString()&#125;&lt;/div&gt;; ReactDOM.render(ele, document.getElementById('example'));&#125;setInterval(tick,1000); 封装到函数中 123456789101112131415function Clock(props)&#123; return ( &lt;div&gt; &lt;h1&gt;hello,world&lt;/h1&gt; &lt;h2&gt;现在时间：&#123;props.date.toLocalTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; )&#125;function tick()&#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125;/&gt;, document.getElementById('root') );&#125;setInterval(tick,1000); 除函数外，还可以封装成 ES6类，另外在 render() 中需要用this.props 替换 props; 1234567891011121314151617class Clock extends React.Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;hello,world&lt;/h1&gt; &lt;h2&gt;现在时间：&#123;this.props.date.toLocalTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;function tick()&#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125;/&gt;, document.getElementById('root') );&#125;setInterval(tick,1000); JSX 语法 React 使用JSX 替代常规的JavaScript 利用HTML语法来创建虚拟 DOM JSX 是在 JavaScript内部实现的1234const ele = &lt;h1&gt;hello,world&lt;/h1&gt;;//JSXvar myDivEle = &lt;div className = 'foo'/&gt;;ReactDOM.render(myDivEle,document.getElementById('example')); React 当中的元素是普通的对象，ReactDOM 可以确保浏览器DOM 的数据内容与 React 元素保持一致通过 ReactDOM.render() 方法将元素渲染到页面上 使用 JSX1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;JSX&lt;/h1&gt; &lt;p data-myattribute="somevalue"&gt;React 是一个用于构建用户界面的JavaScript库&lt;/p&gt; &lt;/div&gt; ,document.getElementById('example');) 可以将 JSX 代码放在独立的文件中，在HTML中引入 1234&lt;body&gt; &lt;div id = "example"&gt;&lt;/div&gt; &lt;script type="text/babel" src="react.js"&gt;&lt;/script&gt;&lt;/body&gt; js表达式JSX 中的JavaScript表达式需要写在 {}中 123456ReactDOM.render( &lt;div&gt; &lt;h1&gt;&#123;i == 1 ? 'true' : 'false'&#125;&lt;/h1&gt; &lt;/div&gt; ,document.getElementById('example');) 样式React 推荐使用内联样式(React 会在指定元素数字后自动添加 px) 12345678var myStyle = &#123; fontSize : 100, color : 'black'&#125;;ReactDOM.render( &lt;h1 style=&#123;myStyle&#125;&gt;hello,world&lt;/h1&gt;, document.getElementById('example')); 注释12345ReactDOM.render( &lt;h1&gt;hello,world&lt;/h1&gt; &#123;/*注释。。。*/&#125;, document.getElementById('example')); 数组在模版中插入数组，数组会自动展开所有成员 12345678var arr = [ &lt;h1&gt;1111&lt;/h1&gt;, &lt;h2&gt;222&lt;/h2&gt;];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example')); React 组件定义React组件的三种方式： 函数式定义的 无状态组件 es5原生方式 React.createClass 定义的组件 es6形式的 extends React.Component 定义的组件无状态函数式组件 接收单一的props对象，返回一个React元素 props 是组件的输入内容，从父组件传递给子组件的数据（属性） props 是只读的；组件名必须以大写字母开头1234567function HelloComponent(props)&#123; return ( &lt;div&gt;hello,&#123;props.name&#125;&lt;/div&gt; )&#125;ReactDOM.render( &lt;HelloComponent name="React"/&gt;,document.getElementById('root')); es5原生方式12345const MyComponent = React.createClass(&#123; render : function()&#123; return &lt;h1&gt;mycomponent&lt;/h1&gt; &#125;&#125;) es6中class类的方式123456789101112131415class MyComponent extends React.Component&#123; constructor()&#123; super(); this.state = &#123; // todo:[1,2,3] &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;hello,world&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; State(状态) 私有的，完全受控于当前组件，组件外部无法进行修改 类定义的组件特有的属性，函数定义的组件无state 构造函数是唯一能初始化this.state的地方12345678910111213class Hello extends React.Component&#123; constructor()&#123; super(); this.state=&#123; name:'React' &#125; &#125; render()&#123; return( &lt;h1&gt;Hello,&#123;this.state.name&#125;&lt;/h1&gt; ) &#125;&#125; 组件的生命周期 只有类定义的组件中才有生命周期函数，函数方式定义的没有 生命周期函数：在某一时刻组件会自动执行的函数 声明周期包含的阶段 初始化 挂载 更新 卸载 错误 初始化 (initialization) constructor() 1234567891011import React,&#123;Component&#125; from 'react';class Test extends Component&#123; //在装载之前被调用 //在函数内应在其他表达式之前调用super(props)，否则this.props在构造函数中是未定义的 constructor(props)&#123; super(props);//调用基类的构造方法，也将父组件的props注入给子组件 this.state = &#123; todo : 'hello' &#125; &#125;&#125; 作用： 初始化状态，通过赋值一个对象到 this.state 绑定事件处理函数到一个实例 挂载 (mounting) static getDerivedStateFromProps()在组件实例化后或接收新属性时会被调用 render()根据组件的props和state，return一个React元素；不负责组件的实际渲染工作 componentDidMount()组件挂载后立即调用，发送请求的好地方？？ 更新 (update)造成组件更新的情况可以看这篇 static getDerivedStateFromProps() shouldComponentUpdate() 在接收到新属性或状态时，在渲染前被调用，返回布尔值 render() getSnapshotBeforeUpdate() 在最新的渲染输出提交给DOM前将会被立即调用 该函数返回的任何值将会 作为参数传递给 componentDidUpdate componentDidUpdate() 卸载 componentWillUnmount() 用于清除组件中使用的定时器错误处理 componentDidCatch() 事件处理事件绑定 React 事件绑定属性的命名采用驼峰式写法 采用JSX语法，需传入一个函数作为事件处理函数，而不是字符串（DOM元素的写法） 调用e.preventDefault()阻止组件的默认行为123456789101112131415161718192021class Click extends React.Component&#123; constructor()&#123; super(); this.state = &#123; context : 'hello' &#125; &#125; handleClick = ()=&gt;&#123; console.log(this); this.setState(&#123;context : 'world'&#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.state.context&#125;&lt;/p&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;click&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Click /&gt;,document.getElementById('root')); this 事件处理函数传参]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件系统]]></title>
    <url>%2F2019%2F09%2F29%2F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[fs 模块1const fs = require('fs');//引入模块 fs 模块中的方法均有同步和异步版本，异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含错误信息（error） 建议使用异步的方法，比同步方法性能更高，速度更快，而且没有阻塞。 打开文件12fs.open(path, flags[,mode], callback(err, fd))//文件路径， 文件打开的行为， 设置文件模式， 回调函数 123456789var fs = require('fs');console.log('准备打开文件');fs.open('input.txt',function(err,fd)&#123; if(err)&#123; return console.log(err); &#125; console.log('文件打开成功');&#125;) 获取文件信息12345678fs.stat(path, callback(err, stats))//path 文件路径//stats 是fs.stats对象var fs = require('fs');fs.stat('path', function(err, stats)&#123; console.log(stats.isFile());&#125;) stats类中的方法 描述 stats.isFile() 判断是否为文件 stats.isDirectory() 判断是否为目录 stats.isSymbolicLink() 判断是否为软链接 12345678910var fs = require('fs');fs.stat('test.js', function(err, stats)&#123; if(err)&#123; return console.error(err); &#125; console.log(stats); console.log('读取文件成功'); console.log('是否为文件：'+stats.isFile());&#125;); 写入文件1234567891011121314fs.writeFile(file,data[, options],callback(err))//如果文件存在，该方法写入的内容会覆盖旧的文件内容var fs = require('fs');fs.writeFile('test.js','想要写入的内容', function(err)&#123; if(err)&#123; return console.error(err); &#125; console.log('写入成功'); fs.readFile('test.js', function(err,data)&#123; if(err) return console.error(err); console.log('异步读取文件数据'+data.toString()); &#125;);&#125;) 读取文件12fs.read(fd, buffer, offset, length, position, callback)//使用文件描述符来读取文件 参数 fd 通过 fs.open() 返回的文件描述符 buffer 数据写入的缓冲区 offset 缓冲区写入的写入偏移量 length 要从文件中读取的字节数 position 文件读取的起始位置 callback(err, bytesRead, buffer) bytesRead表示要读取的字节数，buffer为缓冲区对象 12345678910111213141516var fs = require('fs');var buf = new Buffer.alloc(1024);fs.open('test.js','r+',function(err,fd)&#123; if(err)&#123; return console.error(err); &#125; fs.read(fd,buf,0,buf.length,0,function(err,bytes)&#123; if(err) return console.error(err); console.log(bytes + '字节被读取'); if(bytes &gt; 0)&#123; console.log(buf.slice(0,bytes).toString()); &#125; &#125;);&#125;); 关闭文件123fs.close(fd, callback())//fd 通过 fs.open()返回的文件描述符//callback 无参 123456789101112131415var fs = require('fs');var buf = new Buffer.alloc(1024);fs.open('test.js','r+',function(err,fd)&#123; if(err) console.error(err); fs.read(fd,buf,0,buf.length,0,function(err,bytes)&#123; if(err) console.error(err); if(bytes &gt; 0) console.log(buf.slice(0,bytes).toString()); fs.close(fd,function(err)&#123; if(err) console.error(err); console.log('文件关闭成功'); &#125;); &#125;);&#125;); 创建目录1234567891011fs.mkdir(path[, options],callback())//options的参数：// recursive-以递归的方式创建目录// mode-设置目录权限var fs = require('fs'), dir = process.argvs[2] || __dirname;fs.mkdir(dir, function(err)&#123; if(err) console.error(err);&#125;); 读取目录123456789101112fs.readdir(path,callback)//path//callback(err, files) files为目录下的文件数组列表var fs = require('fs');fs.readdir("/tmp/",function(err,files)&#123; if(err) console.error(err); files.forEach(function(files)&#123; console.log(file); &#125;);&#125;); 删除目录1fs.rmdir(path,callback)]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F09%2F29%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[构建HTTP服务简单的HTTP服务器 123456var http = require('http');http.createServer((req,res)=&gt;&#123; res.writeHead(200,&#123;'Content-Type':'text/plain'&#125;); res.end('hello world\n');&#125;).listen(8080); HTTP HTTP 全称超文本传输协议（HyperText Transfer Protocol）]]></content>
  </entry>
  <entry>
    <title><![CDATA[我和小萌的lovelog]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%88%91%E5%92%8C%E5%B0%8F%E8%90%8C%E7%9A%84lovelog%2F</url>
    <content type="text"><![CDATA[春夏秋冬，你若在场，就很美好]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（三）]]></title>
    <url>%2F2019%2F09%2F22%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[流 stream流是什么 流是数据的集合，在操作大量数据或数据从外部逐段发送过来的时候变得非常有用 可以像通过管道连接linux命令一样，通过pipe组合功能 所有的流都是 EventEmitter 的实例， 使用流pipe方法 使用管道的方式将流连接起来 将可读流的输出连接到可写流的输入，管道的source必须是可读流，destination必须是可写流 1readableSrc.pipe(writableDest); 也可以是双工流/转换流 1readableSrc.pipe(transformStream1).pipe(transformStream2).pipe(finalWritableDest) 流事件（更自定义的方式使用流） 直接通过事件读取，模拟pipe的读取、写入 12345678//readable.pipe(writable)readable.on('data',(chunk)=&gt;&#123; writable.write(chunk);&#125;);readable.on('end',()=&gt;&#123; writable.end();&#125;); 可读流、可写流的事件和方法 Readable Streams的两个重要事件 data 事件，当可读流发送数据给消费者时，会触发 end 事件，可读流数据发送完成时触发 Writeable Streams的两个重要事件 drain 事件，表示可写流可以接收更多数据的信号 finish 事件，当所有数据都被写入底层系统后会触发 可读流的暂停和流动模式可读流的两种模式：暂停模式、流动模式（或拉取模式、推送模式） 所有可读流默认处于暂停模式，可以使用 read() 方法读取数据 当可读流处于流动模式时，需要通过事件监听来处理数据 增加一个 data 事件回调可以把处于暂停模式的流切换到流动模式，同样移除 data 事件回调会把流切换到暂停模式 可以使用 resume() 和 pause() 方法手动在两个模式间切换 实现流实现可写流1const &#123;Writable&#125; = require('streams'); 例如可以继承 Writable 类 12class myWritableStream extends Writable&#123;&#125; 或者，直接给 Writable 构造函数传入配置项来创建一个对象 123456789const &#123;Writable&#125; = require('stream');const outStream = new Writable(&#123; write(chunk, encoding, callback)&#123; console.log(chunk.toString()); callback(); &#125;&#125;);process.stdin.pipe(outStream); 关于 write() 的三个参数： chunk 通常是一个buffer encoding 通常可以忽略，除非 chunk 被配置为不是buffer callback 方法是完成数据处理后要执行的回调函数，用来表示数据能否成功写入，若写入失败，在执行该回调函数时要传入一个错误对象。 实现可读流引入 Readable 接口并通过它创建对象： 1234567891011const &#123;Readable&#125; = require('stream');const inStream = new Readable(&#123;&#125;);//使用 push方法向下游推送数据inStream.push('abcdce');inStream.push('dfslafsa');//当 push一个 null值时，表示后续不会再有数据了inStream.push(null);inStream.pipe(process.stdout); 实现双工/转换流双工流就是要在同一个对象上同时实现可读流和可写流 1234567891011121314151617const &#123;Duplex&#125; = require('stream');const inoutStream = new Duplex(&#123; write(chunk, encoding,callback)&#123; console.log(chunk.toString()); callback(); &#125;, read(size)&#123; this.push(String.fromCharCode(this.currentCharCode++)); if(this.currentCharCode &gt; 90)&#123; this.push(null); &#125; &#125;&#125;);inoutStream.currentCharCode = 65;process.stdin.pipe(inoutStream).pipe(process.stdout); 转换流的 transform 方法 12345678910const &#123;Transform&#125; = require('stream');const upperCaseTr = new Transform(&#123; transform(chunk, encoding, callback)&#123; this.push(chunk.toString().toUpperCase()); callback(); &#125;&#125;);process.stdin.pipe(upperCaseTr).pipe(process.stdout);]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（二）]]></title>
    <url>%2F2019%2F09%2F21%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[事件所有的异步I/O操作在完成时都会发送一个事件到事件队列；许多对象都会分发事件，所有这些产生事件的对象都是 events.EventEmitter 的实例 例如fs.readStream对象会在文件被打开的时候触发一个事件 EventEmitter 类 核心：事件触发与事件监听器功能的封装 event对象注册了事件some_event 的监听器，通过setTimeout在1s后向event对象发送事件some_event，此时会调用监听器 1234567891011const EventEmitter = require('events').EventEmitter;var event = new EventEmitter();event.on('some_event',function()&#123; console.log('s_e 事件触发');&#125;);setTimeout(function()&#123; event.emit('some_event');&#125;,1000);//1s后//s_e 事件触发 EventEmitter 的每个事件由一个事件名和若干个参数组成，且EventEmitter 支持若干个事件监听器 当事件被触发时，监听器被依次调用，事件参数作为回调函数参数传递 12345678910111213const events = require('events');var e = new events.EventEmitter();e.on('some_event',function(arg1,arg2)&#123; console.log('listener1',arg1,arg2);&#125;);e.on('some_event',function(arg1,arg2)&#123; console.log('listener2',arg1,arg2);&#125;);e.emit('some_event','arg1 参数','arg2 参数');//listener1 arg1 参数 arg2 参数//listener2 arg1 参数 arg2 参数 on 用于绑定事件函数，emit 用于触发一个事件 方法 on(event,listener)为指定事件注册监听器，接收一个字符串event和一个回调函数 123server.on('connection',function(stream)&#123; console.log('someone connected');&#125;); addListener(event,listener)为指定事件添加一个监听器到监听器数组的尾部 once(event,listener)为指定事件注册一个单次监听器，最多触发一次，触发后立即解除 123server.once('connection',function(stream)&#123; console.log('once');&#125;); emit(event,[arg1],[arg2],[…])按监听器的顺序执行，如果事件有注册监听返回true removeListener(event,listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器，第一个参数是事件名称，第二个是回调函数 12345var callback = function(stream)&#123; console.log('some connected');&#125;;server.on('connection',callback);server.removeListener('connection',callback); 类方法 listenerCount(emitter,event)返回指定事件的监听器数量1events.emitter.listenerCount(eventName) 事件 newListener在添加新监听器时被触发 removeListener从指定监听器数组中删除一个监听器 12345678910111213141516171819202122232425262728293031var events = require('events');var eventEmitter = new events.EventEmitter();//监听器var listener1 = function listener1()&#123; console.log('监听器 listener1执行');&#125;var listener2 = function listener2()&#123; console.log('监听器 listener2执行');&#125;//绑定connection事件，处理函数为listenereventEmitter.addListener('connection',listener1);eventEmitter.on('connection',listener2);//打印监听器数量var eventListeners = eventEmitter.listenerCount('connection');console.log(eventListeners+"个监听器监听连接事件");//处理connection事件eventEmitter.emit('connection');//移除绑定的 listener1 函数eventEmitter.removeListener('connection',listener1);console.log('listener1 不再受监听');//触发连接事件eventEmitter.emit('connection');eventListeners = eventEmitter.listenerCount('connection');console.log(eventListeners+"个监听器监听连接事件");console.log('over'); 1234567//2 个监听器监听连接事件//监听器listener1 执行//监听器listener2 执行//listener1 不再受监听//监听器listener2 执行//1 个监听器监听连接事件//over 继承EventEmitter类 原型继承EventEmitter类 12345678910111213141516171819202122232425const EventEmitter = require('events').EventEmitter;function Dog(name,energy)&#123; var _name,_energy; var that = this; EventEmitter.call(this); _name = name; _energy = energy; //定时器 var timer = setInterval(()=&gt;&#123; if(_energy &gt; 0)&#123; that.emit('bark'); _energy--; &#125;else&#123; clearInterval(timer); &#125; &#125;,1000); this.getName = ()=&gt;_name; this.getEnergy = ()=&gt;_energy;&#125;Dog.prototype = EventEmitter.prototype;module.exports = Dog;//导出模块 123456789101112const Dog = require('./02-dog.js');//引入模块//实例化对象var taidi = new Dog('taidi',4);var zangao = new Dog('zangao',10);taidi.on('bark',onBark);//触发事件zangao.on('bark',onBark);function onBark()&#123; console.log('%s barked. energy:%s',this.getName(),this.getEnergy());&#125;]]></content>
      <tags>
        <tag>nodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（一）]]></title>
    <url>%2F2019%2F09%2F02%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[nodejs是一个基于chrome v8引擎的JavaScript运行环境 仅使用一个线程 non-blocking I/O 非阻塞 一个线程永远在执行计算操作 event-driven 事件驱动 一些在centeOS中的常用命令 ls 查看当前目录 cd .. 切换到上级目录 mkdir 创建文件夹 touch file 新建文件 vim file 使用vim编辑文件 :wq 保存退出 :w 仅保存 http 内置模块123456const http = require('http');//引入http模块http.createServer((req,res)=&gt;&#123;//创建服务//req请求对象，res响应对象 res.end('hello world');//结束响应&#125;).listen(8080);//通过8080端口监听 全局获取命令行参数 123var arg = process.argv[];//process是全局对象，argv返回一个包含命令行参数的数组//第一个元素是'node'，第二个元素是文件名，接下来是命令行参数 当前进程的PID [ process.pid ] 退出码 [ process.exit(code) ] 输入输出流 [ process.stdout ] 12process.stdout.write('hello world');//指向标准输出流的可写的流(writable stream) [ process.stdin ] 1234567891011121314process.stdin.resume();var a,b;process.stdout.write('请输入a:');process.stdin.on('data',function(data)&#123; if(a == undefined)&#123; a = Number(data); process.stdout.write('请输入b：'); &#125;else&#123; b = Number(data); process.stdout.write('结果：'+ (a+b)); process.exit(); &#125;&#125;);//一个指向标准输入流的可读流（readable stream），标准输入流默认是暂停的，所以b必须调用process.stdin.resume()来恢复接收 [ process.stderr ] 12process.stderr.write('输出标出错误流');//一个指向标准错误流的可写的流（writable stream） 处理信号量 接收信号量，并对（SIGINT 和 SIGSTP）进行处理 123process.on('SIGINT',function()&#123; console.log('Got SIGINT. Press Control-D to exit.');&#125;) 六个定时器函数1234567891011setTimeout(()=&gt;console.log(1));setImmediate(()=&gt;console.log(2));process.nextTick(()=&gt;console.log(3));Promise.resolve().then(()=&gt;console.log(4));(()=&gt;console.log(5))();//立即执行函数//5//3//4//1//2 同步任务比异步任务更早执行 异步任务又分为两种： 追加在本轮循环（event loop）的异步任务 追加在次轮循环的异步任务 本轮循环一定早于次轮循环执行 process.nextTick() 和 Promise的回调函数追加在本轮循环；setTimeout、setInterval、setImmediate的回调函数追加在次轮循环 [ setTimeout() ] [ setInterval() ] [ setImmediate() ] [ process.nextTick() ]]]></content>
      <tags>
        <tag>nodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[”零基础向搭建个人博客]]></title>
    <url>%2F2019%2F07%2F11%2F%E2%80%9D%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%90%91%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[首先要选择blog的框架 hexo 插件多，所以选了从这个开始入手 hugo 编译性能较好 jekyll 迁移和部署较方便 安装hexo安装 node.js 常用命令123npm install -g hexo //安装hexohexo init //初始化hexo //确认是否安装成功 安装 git 通过GitHub Pages部署到服务器]]></content>
  </entry>
  <entry>
    <title><![CDATA[test_one]]></title>
    <url>%2F2019%2F07%2F10%2Ftest-one%2F</url>
    <content type="text"><![CDATA[HTML构建页面的结构、CSS代码描述页面样式、JavaScript代码设计页面行为（动态特效）JavaScript是一种基于 对象 和 事件驱动 并具有安全性能的脚本语言。 123&lt;script type=&quot;text/javascript&quot;&gt; alert(&apos;hello javascript&apos;);&lt;/script&gt; 在浏览器中弹出一个提醒框 JavaScript是一种基于 对象 和 事件驱动 并具有安全性能的脚本语言。 &emsp;Java是一种面向对象的程序开发语言，需要“编译-链接-运行”&emsp;JavaScript只需经过“编写-运行” -特点:不用给变量指定数据类型（动态类型）、一个变量可以赋不同类型的值（弱类型）、解释性语言不需要编译，方便调试（简单性）、依赖浏览器本身，与操作环境无关（跨平台性）、主流浏览器统一支持的语言（必要性）、兼容性差 原始数据类型–Number、String、Boolean、Undefined、Null–使用 typeof 运算符，判断变量在某一时刻的数据类型–弱类型是指不同类型的变量之间可以相互赋值，但在某一时刻，一个变量只存在某一种数据类型]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
