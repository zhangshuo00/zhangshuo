<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React笔记（一）]]></title>
    <url>%2F2019%2F10%2F08%2FReact%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[定义 react 是一个用于构建用户界面的JavaScript库 react 主要用于构建UI，很多人认为是MVC中的V MVC即 模型 (moudel) - 视图 (view) - 控制器 (controller) 特点 组件：通过 react 构建组件，使得代码更加容易得到复用 JSX：是JavaScript 语法的扩展 单向相应的数据流：从而减少了重复代码 灵活：react 可以和已知的库或框架配合 高效：react 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互 声明式设计：react 采用声明范式，可以轻松描述应用 React 元素渲染 元素是构成React 应用的最小单位，用于描述屏幕上输出的内容 1const ele = &lt;h1&gt;hello,world&lt;/h1&gt;; 将元素渲染到 DOM 中123//在HTML页面中添加一个id = 'example' 的 &lt;div&gt;&lt;div id='example'&gt;&lt;/div&gt;//在此 div 中的所有内容都将由 React DOM 来管理，称为 “根DOM” 结点 在用 React 开发应用时一般只会定义一个根节点 JSX 语法 React 使用JSX 替代常规的JavaScript 利用HTML语法来创建虚拟 DOM JSX 是在 JavaScript内部实现的1234const ele = &lt;h1&gt;hello,world&lt;/h1&gt;;//JSXvar myDivEle = &lt;div className = 'foo'/&gt;;ReactDOM.render(myDivEle,document.getElementById('example')); React 当中的元素是普通的对象，ReactDOM 可以确保浏览器DOM 的数据内容与 React 元素保持一致通过 ReactDOM.render() 方法将元素渲染到页面上 使用 JSX1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;JSX&lt;/h1&gt; &lt;p data-myattribute="somevalue"&gt;React 是一个用于构建用户界面的JavaScript库&lt;/p&gt; &lt;/div&gt; ,document.getElementById('example');) 可以将 JSX 代码放在独立的文件中，在HTML中引入 1234&lt;body&gt; &lt;div id = "example"&gt;&lt;/div&gt; &lt;script type="text/babel" src="react.js"&gt;&lt;/script&gt;&lt;/body&gt; js表达式JSX 中的JavaScript表达式需要写在 {}中 123456ReactDOM.render( &lt;div&gt; &lt;h1&gt;&#123;i == 1 ? 'true' : 'false'&#125;&lt;/h1&gt; &lt;/div&gt; ,document.getElementById('example');) 样式React 推荐使用内联样式(React 会在指定元素数字后自动添加 px) 12345678var myStyle = &#123; fontSize : 100, color : 'black'&#125;;ReactDOM.render( &lt;h1 style=&#123;myStyle&#125;&gt;hello,world&lt;/h1&gt;, document.getElementById('example')); 注释12345ReactDOM.render( &lt;h1&gt;hello,world&lt;/h1&gt; &#123;/*注释。。。*/&#125;, document.getElementById('example')); 数组在模版中插入数组，数组会自动展开所有成员 12345678var arr = [ &lt;h1&gt;1111&lt;/h1&gt;, &lt;h2&gt;222&lt;/h2&gt;];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example')); React 组件]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件系统]]></title>
    <url>%2F2019%2F09%2F29%2F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[fs 模块1const fs = require('fs');//引入模块 fs 模块中的方法均有同步和异步版本，异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含错误信息（error） 建议使用异步的方法，比同步方法性能更高，速度更快，而且没有阻塞。 打开文件12fs.open(path, flags[,mode], callback(err, fd))//文件路径， 文件打开的行为， 设置文件模式， 回调函数 123456789var fs = require('fs');console.log('准备打开文件');fs.open('input.txt',function(err,fd)&#123; if(err)&#123; return console.log(err); &#125; console.log('文件打开成功');&#125;) 获取文件信息12345678fs.stat(path, callback(err, stats))//path 文件路径//stats 是fs.stats对象var fs = require('fs');fs.stat('path', function(err, stats)&#123; console.log(stats.isFile());&#125;) stats类中的方法 描述 stats.isFile() 判断是否为文件 stats.isDirectory() 判断是否为目录 stats.isSymbolicLink() 判断是否为软链接 12345678910var fs = require('fs');fs.stat('test.js', function(err, stats)&#123; if(err)&#123; return console.error(err); &#125; console.log(stats); console.log('读取文件成功'); console.log('是否为文件：'+stats.isFile());&#125;); 写入文件1234567891011121314fs.writeFile(file,data[, options],callback(err))//如果文件存在，该方法写入的内容会覆盖旧的文件内容var fs = require('fs');fs.writeFile('test.js','想要写入的内容', function(err)&#123; if(err)&#123; return console.error(err); &#125; console.log('写入成功'); fs.readFile('test.js', function(err,data)&#123; if(err) return console.error(err); console.log('异步读取文件数据'+data.toString()); &#125;);&#125;) 读取文件12fs.read(fd, buffer, offset, length, position, callback)//使用文件描述符来读取文件 参数 fd 通过 fs.open() 返回的文件描述符 buffer 数据写入的缓冲区 offset 缓冲区写入的写入偏移量 length 要从文件中读取的字节数 position 文件读取的起始位置 callback(err, bytesRead, buffer) bytesRead表示要读取的字节数，buffer为缓冲区对象 12345678910111213141516var fs = require('fs');var buf = new Buffer.alloc(1024);fs.open('test.js','r+',function(err,fd)&#123; if(err)&#123; return console.error(err); &#125; fs.read(fd,buf,0,buf.length,0,function(err,bytes)&#123; if(err) return console.error(err); console.log(bytes + '字节被读取'); if(bytes &gt; 0)&#123; console.log(buf.slice(0,bytes).toString()); &#125; &#125;);&#125;); 关闭文件123fs.close(fd, callback())//fd 通过 fs.open()返回的文件描述符//callback 无参 123456789101112131415var fs = require('fs');var buf = new Buffer.alloc(1024);fs.open('test.js','r+',function(err,fd)&#123; if(err) console.error(err); fs.read(fd,buf,0,buf.length,0,function(err,bytes)&#123; if(err) console.error(err); if(bytes &gt; 0) console.log(buf.slice(0,bytes).toString()); fs.close(fd,function(err)&#123; if(err) console.error(err); console.log('文件关闭成功'); &#125;); &#125;);&#125;); 创建目录1234567891011fs.mkdir(path[, options],callback())//options的参数：// recursive-以递归的方式创建目录// mode-设置目录权限var fs = require('fs'), dir = process.argvs[2] || __dirname;fs.mkdir(dir, function(err)&#123; if(err) console.error(err);&#125;); 读取目录123456789101112fs.readdir(path,callback)//path//callback(err, files) files为目录下的文件数组列表var fs = require('fs');fs.readdir("/tmp/",function(err,files)&#123; if(err) console.error(err); files.forEach(function(files)&#123; console.log(file); &#125;);&#125;); 删除目录1fs.rmdir(path,callback)]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F09%2F29%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[我和小萌的lovelog]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%88%91%E5%92%8C%E5%B0%8F%E8%90%8C%E7%9A%84lovelog%2F</url>
    <content type="text"><![CDATA[春夏秋冬，你若在场，就很美好]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（三）]]></title>
    <url>%2F2019%2F09%2F22%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[流 stream流是什么 流是数据的集合，在操作大量数据或数据从外部逐段发送过来的时候变得非常有用 可以像通过管道连接linux命令一样，通过pipe组合功能 所有的流都是 EventEmitter 的实例， 使用流pipe方法 使用管道的方式将流连接起来 将可读流的输出连接到可写流的输入，管道的source必须是可读流，destination必须是可写流 1readableSrc.pipe(writableDest); 也可以是双工流/转换流 1readableSrc.pipe(transformStream1).pipe(transformStream2).pipe(finalWritableDest) 流事件（更自定义的方式使用流） 直接通过事件读取，模拟pipe的读取、写入 12345678//readable.pipe(writable)readable.on('data',(chunk)=&gt;&#123; writable.write(chunk);&#125;);readable.on('end',()=&gt;&#123; writable.end();&#125;); 可读流、可写流的事件和方法 Readable Streams的两个重要事件 data 事件，当可读流发送数据给消费者时，会触发 end 事件，可读流数据发送完成时触发 Writeable Streams的两个重要事件 drain 事件，表示可写流可以接收更多数据的信号 finish 事件，当所有数据都被写入底层系统后会触发 可读流的暂停和流动模式可读流的两种模式：暂停模式、流动模式（或拉取模式、推送模式） 所有可读流默认处于暂停模式，可以使用 read() 方法读取数据 当可读流处于流动模式时，需要通过事件监听来处理数据 增加一个 data 事件回调可以把处于暂停模式的流切换到流动模式，同样移除 data 事件回调会把流切换到暂停模式 可以使用 resume() 和 pause() 方法手动在两个模式间切换 实现流实现可写流1const &#123;Writable&#125; = require('streams'); 例如可以继承 Writable 类 12class myWritableStream extends Writable&#123;&#125; 或者，直接给 Writable 构造函数传入配置项来创建一个对象 123456789const &#123;Writable&#125; = require('stream');const outStream = new Writable(&#123; write(chunk, encoding, callback)&#123; console.log(chunk.toString()); callback(); &#125;&#125;);process.stdin.pipe(outStream); 关于 write() 的三个参数： chunk 通常是一个buffer encoding 通常可以忽略，除非 chunk 被配置为不是buffer callback 方法是完成数据处理后要执行的回调函数，用来表示数据能否成功写入，若写入失败，在执行该回调函数时要传入一个错误对象。 实现可读流引入 Readable 接口并通过它创建对象： 1234567891011const &#123;Readable&#125; = require('stream');const inStream = new Readable(&#123;&#125;);//使用 push方法向下游推送数据inStream.push('abcdce');inStream.push('dfslafsa');//当 push一个 null值时，表示后续不会再有数据了inStream.push(null);inStream.pipe(process.stdout); 实现双工/转换流双工流就是要在同一个对象上同时实现可读流和可写流 1234567891011121314151617const &#123;Duplex&#125; = require('stream');const inoutStream = new Duplex(&#123; write(chunk, encoding,callback)&#123; console.log(chunk.toString()); callback(); &#125;, read(size)&#123; this.push(String.fromCharCode(this.currentCharCode++)); if(this.currentCharCode &gt; 90)&#123; this.push(null); &#125; &#125;&#125;);inoutStream.currentCharCode = 65;process.stdin.pipe(inoutStream).pipe(process.stdout); 转换流的 transform 方法 12345678910const &#123;Transform&#125; = require('stream');const upperCaseTr = new Transform(&#123; transform(chunk, encoding, callback)&#123; this.push(chunk.toString().toUpperCase()); callback(); &#125;&#125;);process.stdin.pipe(upperCaseTr).pipe(process.stdout);]]></content>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（二）]]></title>
    <url>%2F2019%2F09%2F21%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[事件所有的异步I/O操作在完成时都会发送一个事件到事件队列；许多对象都会分发事件，所有这些产生事件的对象都是 events.EventEmitter 的实例 例如fs.readStream对象会在文件被打开的时候触发一个事件 EventEmitter 类 核心：事件触发与事件监听器功能的封装 event对象注册了事件some_event 的监听器，通过setTimeout在1s后向event对象发送事件some_event，此时会调用监听器 1234567891011const EventEmitter = require('events').EventEmitter;var event = new EventEmitter();event.on('some_event',function()&#123; console.log('s_e 事件触发');&#125;);setTimeout(function()&#123; event.emit('some_event');&#125;,1000);//1s后//s_e 事件触发 EventEmitter 的每个事件由一个事件名和若干个参数组成，且EventEmitter 支持若干个事件监听器 当事件被触发时，监听器被依次调用，事件参数作为回调函数参数传递 12345678910111213const events = require('events');var e = new events.EventEmitter();e.on('some_event',function(arg1,arg2)&#123; console.log('listener1',arg1,arg2);&#125;);e.on('some_event',function(arg1,arg2)&#123; console.log('listener2',arg1,arg2);&#125;);e.emit('some_event','arg1 参数','arg2 参数');//listener1 arg1 参数 arg2 参数//listener2 arg1 参数 arg2 参数 on 用于绑定事件函数，emit 用于触发一个事件 方法 on(event,listener)为指定事件注册监听器，接收一个字符串event和一个回调函数 123server.on('connection',function(stream)&#123; console.log('someone connected');&#125;); addListener(event,listener)为指定事件添加一个监听器到监听器数组的尾部 once(event,listener)为指定事件注册一个单次监听器，最多触发一次，触发后立即解除 123server.once('connection',function(stream)&#123; console.log('once');&#125;); emit(event,[arg1],[arg2],[…])按监听器的顺序执行，如果事件有注册监听返回true removeListener(event,listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器，第一个参数是事件名称，第二个是回调函数 12345var callback = function(stream)&#123; console.log('some connected');&#125;;server.on('connection',callback);server.removeListener('connection',callback); 类方法 listenerCount(emitter,event)返回指定事件的监听器数量1events.emitter.listenerCount(eventName) 事件 newListener在添加新监听器时被触发 removeListener从指定监听器数组中删除一个监听器 12345678910111213141516171819202122232425262728293031var events = require('events');var eventEmitter = new events.EventEmitter();//监听器var listener1 = function listener1()&#123; console.log('监听器 listener1执行');&#125;var listener2 = function listener2()&#123; console.log('监听器 listener2执行');&#125;//绑定connection事件，处理函数为listenereventEmitter.addListener('connection',listener1);eventEmitter.on('connection',listener2);//打印监听器数量var eventListeners = eventEmitter.listenerCount('connection');console.log(eventListeners+"个监听器监听连接事件");//处理connection事件eventEmitter.emit('connection');//移除绑定的 listener1 函数eventEmitter.removeListener('connection',listener1);console.log('listener1 不再受监听');//触发连接事件eventEmitter.emit('connection');eventListeners = eventEmitter.listenerCount('connection');console.log(eventListeners+"个监听器监听连接事件");console.log('over'); 1234567//2 个监听器监听连接事件//监听器listener1 执行//监听器listener2 执行//listener1 不再受监听//监听器listener2 执行//1 个监听器监听连接事件//over 继承EventEmitter类 原型继承EventEmitter类 12345678910111213141516171819202122232425const EventEmitter = require('events').EventEmitter;function Dog(name,energy)&#123; var _name,_energy; var that = this; EventEmitter.call(this); _name = name; _energy = energy; //定时器 var timer = setInterval(()=&gt;&#123; if(_energy &gt; 0)&#123; that.emit('bark'); _energy--; &#125;else&#123; clearInterval(timer); &#125; &#125;,1000); this.getName = ()=&gt;_name; this.getEnergy = ()=&gt;_energy;&#125;Dog.prototype = EventEmitter.prototype;module.exports = Dog;//导出模块 123456789101112const Dog = require('./02-dog.js');//引入模块//实例化对象var taidi = new Dog('taidi',4);var zangao = new Dog('zangao',10);taidi.on('bark',onBark);//触发事件zangao.on('bark',onBark);function onBark()&#123; console.log('%s barked. energy:%s',this.getName(),this.getEnergy());&#125;]]></content>
      <tags>
        <tag>nodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeJs笔记（一）]]></title>
    <url>%2F2019%2F09%2F02%2FnodeJs%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[nodejs是一个基于chrome v8引擎的JavaScript运行环境 仅使用一个线程 non-blocking I/O 非阻塞 一个线程永远在执行计算操作 event-driven 事件驱动 一些在centeOS中的常用命令 ls 查看当前目录 cd .. 切换到上级目录 mkdir 创建文件夹 touch file 新建文件 vim file 使用vim编辑文件 :wq 保存退出 :w 仅保存 http 内置模块123456const http = require('http');//引入http模块http.createServer((req,res)=&gt;&#123;//创建服务//req请求对象，res响应对象 res.end('hello world');//结束响应&#125;).listen(8080);//通过8080端口监听 全局获取命令行参数 123var arg = process.argv[];//process是全局对象，argv返回一个包含命令行参数的数组//第一个元素是'node'，第二个元素是文件名，接下来是命令行参数 当前进程的PID [ process.pid ] 退出码 [ process.exit(code) ] 输入输出流 [ process.stdout ] 12process.stdout.write('hello world');//指向标准输出流的可写的流(writable stream) [ process.stdin ] 1234567891011121314process.stdin.resume();var a,b;process.stdout.write('请输入a:');process.stdin.on('data',function(data)&#123; if(a == undefined)&#123; a = Number(data); process.stdout.write('请输入b：'); &#125;else&#123; b = Number(data); process.stdout.write('结果：'+ (a+b)); process.exit(); &#125;&#125;);//一个指向标准输入流的可读流（readable stream），标准输入流默认是暂停的，所以b必须调用process.stdin.resume()来恢复接收 [ process.stderr ] 12process.stderr.write('输出标出错误流');//一个指向标准错误流的可写的流（writable stream） 处理信号量 接收信号量，并对（SIGINT 和 SIGSTP）进行处理 123process.on('SIGINT',function()&#123; console.log('Got SIGINT. Press Control-D to exit.');&#125;) 六个定时器函数1234567891011setTimeout(()=&gt;console.log(1));setImmediate(()=&gt;console.log(2));process.nextTick(()=&gt;console.log(3));Promise.resolve().then(()=&gt;console.log(4));(()=&gt;console.log(5))();//立即执行函数//5//3//4//1//2 同步任务比异步任务更早执行 异步任务又分为两种： 追加在本轮循环（event loop）的异步任务 追加在次轮循环的异步任务 本轮循环一定早于次轮循环执行 process.nextTick() 和 Promise的回调函数追加在本轮循环；setTimeout、setInterval、setImmediate的回调函数追加在次轮循环 [ setTimeout() ] [ setInterval() ] [ setImmediate() ] [ process.nextTick() ]]]></content>
      <tags>
        <tag>nodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[”零基础向搭建个人博客]]></title>
    <url>%2F2019%2F07%2F11%2F%E2%80%9D%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%90%91%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[首先要选择blog的框架 hexo 插件多，所以选了从这个开始入手 hugo 编译性能较好 jekyll 迁移和部署较方便 安装hexo安装 node.js 常用命令123npm install -g hexo //安装hexohexo init //初始化hexo //确认是否安装成功 安装 git 通过GitHub Pages部署到服务器]]></content>
  </entry>
  <entry>
    <title><![CDATA[test_one]]></title>
    <url>%2F2019%2F07%2F10%2Ftest-one%2F</url>
    <content type="text"><![CDATA[HTML构建页面的结构、CSS代码描述页面样式、JavaScript代码设计页面行为（动态特效）JavaScript是一种基于 对象 和 事件驱动 并具有安全性能的脚本语言。 123&lt;script type=&quot;text/javascript&quot;&gt; alert(&apos;hello javascript&apos;);&lt;/script&gt; 在浏览器中弹出一个提醒框 JavaScript是一种基于 对象 和 事件驱动 并具有安全性能的脚本语言。 &emsp;Java是一种面向对象的程序开发语言，需要“编译-链接-运行”&emsp;JavaScript只需经过“编写-运行” -特点:不用给变量指定数据类型（动态类型）、一个变量可以赋不同类型的值（弱类型）、解释性语言不需要编译，方便调试（简单性）、依赖浏览器本身，与操作环境无关（跨平台性）、主流浏览器统一支持的语言（必要性）、兼容性差 原始数据类型–Number、String、Boolean、Undefined、Null–使用 typeof 运算符，判断变量在某一时刻的数据类型–弱类型是指不同类型的变量之间可以相互赋值，但在某一时刻，一个变量只存在某一种数据类型]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
